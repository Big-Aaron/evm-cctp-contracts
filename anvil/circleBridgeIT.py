from typing import List, Dict
from web3 import Web3
import solcx
import unittest
import time

# All addresses are automatically generated by anvil at startup
addresses = {
    "attester": Web3.toChecksumAddress("0xbcd4042de499d14e55001ccbb24a551f3b954096"),
    "eth_usdc_master_minter": Web3.toChecksumAddress("0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266"),
    "eth_message_transmitter_deployer": Web3.toChecksumAddress("0x3c44cdddb6a900fa2b585dd299e03d12fa4293bc"),
    "eth_circle_bridge_deployer": Web3.toChecksumAddress("0x90f79bf6eb2c4f870365e785982e1f101e93b906"),
    "eth_circle_minter_deployer": Web3.toChecksumAddress("0x15d34aaf54267db7d7c367839aaf71a00a2c6a65"),
    "eth_bridge_user": Web3.toChecksumAddress("0x23618e81e3f5cdf7f54c3d65f7fbc0abf5b21e8f"),
    "avax_usdc_master_minter": Web3.toChecksumAddress("0x70997970c51812dc3a010c7d01b50e0d17dc79c8"),
    "avax_message_transmitter_deployer": Web3.toChecksumAddress("0x9965507d1a55bcc2695c58ba16fb37d819b0a4dc"),
    "avax_circle_bridge_deployer": Web3.toChecksumAddress("0x976ea74026e726554db657fa54763abd0c3a0aa9"),
    "avax_circle_minter_deployer": Web3.toChecksumAddress("0x14dc79964da2c08b23698b3d3cc7ca32193d9955"),
    "avax_bridge_user": Web3.toChecksumAddress("0xa0ee7a142d267c1f36714e4a8f75612f20a79720")
}

# All keys correspond with the addresses generated by anvil at startup
keys = {
    "attester": "0xf214f2b2cd398c806f84e317254e0f0b801d0643303237d97a22a48e01628897",
    "eth_usdc_master_minter": "0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80",
    "eth_message_transmitter_deployer": "0x5de4111afa1a4b94908f83103eb1f1706367c2e68ca870fc3fb9a804cdab365a",
    "eth_circle_bridge_deployer": "0x7c852118294e51e653712a81e05800f419141751be58f605c371e15141b007a6",
    "eth_circle_minter_deployer": "0x47e179ec197488593b187f80a00eb0da91f1b9d0b13f8733639f19c30a34926a",
    "eth_bridge_user": "0xdbda1821b80551c9d65939329250298aa3472ba22feea921c0cf5d620ea67b97",
    "avax_usdc_master_minter": "0x59c6995e998f97a5a0044966f0945389dc9e86dae88c7a8412f4603b6b78690d",
    "avax_message_transmitter_deployer": "0x8b3a350cf5c34c9194ca85829a2df0ec3153be0318b5e2d3348e872092edffba",
    "avax_circle_bridge_deployer": "0x92db14e403b83dfe3df233f83dfa3a0d7096f21ca9b0d6d6b8d88b2b4ec1564e",
    "avax_circle_minter_deployer": "0x4bbbf85ce3377467afe5d46f804f221813b2bb87f24d81f60f1fcdbf7cbf4356",
    "avax_bridge_user": "0x2a871d0798f97d79848a013d4936a73bf4cc922c825d33c1cf7073dff6d409c6"
}

# Miscellaneous fixed values for contract deployment and configuration 
eth_domain = 0
avax_domain = 1
maxMessageBodySize = 8192
version = 0
message_body_version = 0
minter_allowance = 1000
mint_amount = 100

def compile_source_file(file_path: str, contract_name: str, version: str = '0.7.6') -> Dict:
    """
    Takes in file path to a Solidity contract, contract name, and optional version params
    and returns a dictionary representing the compiled contract.
    """
    solcx.install_solc(version)
    solcx.set_solc_version(version)
    return solcx.compile_files(
        [file_path],
        output_values = ["abi", "bin"],
        import_remappings = {
            "@memview-sol/": "lib/memview-sol/",
            "@openzeppelin/": "lib/openzeppelin-contracts/",
            "ds-test/": "lib/ds-test/src/",
            "forge-std/": "lib/forge-std/src/"
        },
        allow_paths = ["."]
    )[f'{file_path}:{contract_name}']

class TestCircleBridgeWithUSDC(unittest.TestCase):
    def deploy_contract_from_source(
        self, 
        file_path: str, 
        contract_name: str, 
        version: str = '0.7.6', 
        libraries: Dict = {},
        constructor_args: List = [],
        caller = ""
    ):
        """
        Takes in a Solidity contract file path, contract name and optional Solidity 
        compiler version, dictionary of libraries to link, arguments for contract
        constructor, and caller address to compile, deploy, and construct a Solidity 
        contract. Returns a web3 contract object representing the deployed contract.
        """

        # Compile
        contract_interface = compile_source_file(file_path, contract_name, version)

        # Deploy
        if caller:
            unsigned_tx = self.w3.eth.contract(
                abi=contract_interface['abi'],
                bytecode=solcx.link_code(contract_interface['bin'], libraries)
            ).constructor(*constructor_args).build_transaction({
                'nonce': self.w3.eth.get_transaction_count(addresses[caller]),
                'from': addresses[caller]
            })
            
            signed_tx = self.w3.eth.account.sign_transaction(unsigned_tx, keys[caller])
            tx_hash = self.w3.eth.send_raw_transaction(signed_tx.rawTransaction)
        else:
            tx_hash = self.w3.eth.contract(
                abi=contract_interface['abi'],
                bytecode=solcx.link_code(contract_interface['bin'], libraries)
            ).constructor(*constructor_args).transact()

        self.confirm_transaction(tx_hash)

        # Retrieve address and deployed contract
        address = self.w3.eth.get_transaction_receipt(tx_hash)['contractAddress']
        return self.w3.eth.contract(
            address=address,
            abi=contract_interface['abi']
        )

    def send_transaction(self, function_call, caller: str): 
        """
        Takes in an initialized function call and a designated caller and builds,
        signs, and sends the transaction. Verifies the transaction was received.
        """
        unsigned_tx = function_call.build_transaction({
            'nonce': self.w3.eth.get_transaction_count(addresses[caller]),
            'from': addresses[caller]
        })
        signed_tx = self.w3.eth.account.sign_transaction(unsigned_tx, keys[caller])
        tx_hash = self.w3.eth.send_raw_transaction(signed_tx.rawTransaction)
        self.confirm_transaction(tx_hash)

    def verify_balances(self, expected_eth_usdc_balance, expected_avax_usdc_balance):
        """
        Verifies that the USDC balances at the test eth_bridge_user and avax_bridge_user
        accounts matches the input expected values.
        """
        assert(self.eth_usdc.functions.balanceOf(addresses["eth_bridge_user"]).call() == expected_eth_usdc_balance)
        assert(self.avax_usdc.functions.balanceOf(addresses["avax_bridge_user"]).call() == expected_avax_usdc_balance)

    def to_32byte_hex(self, address):
        """
        Converts a hex address to its zero-padded 32-byte representation.
        """
        return Web3.toHex(Web3.toBytes(hexstr=address).rjust(32, b'\0'))

    def confirm_transaction(self, tx_hash, timeout=30):
        """
        Waits until transaction receipt associated with tx_hash confirms completion.
        """
        counter = 0
        while counter < timeout:
            try:
                if self.w3.eth.get_transaction_receipt(tx_hash).status == 1:
                    return
            except:
                pass
            counter += 1
            time.sleep(1)
        
        raise RuntimeError(f"Transaction with hash {tx_hash} did not complete within {timeout} seconds")

    def setUp(self):
        # Connect to node
        self.w3 = Web3(Web3.HTTPProvider('http://0.0.0.0:8545'))
        assert self.w3.isConnected()

        # Deploy and initialize USDC on ETH
        self.eth_usdc = self.deploy_contract_from_source('lib/centre-tokens.git/contracts/v2/FiatTokenV2_1.sol', 'FiatTokenV2_1', '0.6.12')
        self.send_transaction(self.eth_usdc.functions.initialize(
            "USDC",
            "USDC",
            "USDC",
            0,
            addresses["eth_usdc_master_minter"],
            self.w3.eth.account.create().address,
            self.w3.eth.account.create().address,
            addresses["eth_usdc_master_minter"]
        ), "eth_usdc_master_minter")
        self.send_transaction(self.eth_usdc.functions.initializeV2("USDC"), "eth_usdc_master_minter")
        self.send_transaction(self.eth_usdc.functions.initializeV2_1(Web3.toChecksumAddress("0xb794f5ea0ba39494ce839613fffba74279579268")), "eth_usdc_master_minter")

        # Deploy and initialize USDC on AVAX
        self.avax_usdc = self.deploy_contract_from_source('lib/centre-tokens.git/contracts/v2/FiatTokenV2_1.sol', 'FiatTokenV2_1', '0.6.12')
        self.send_transaction(self.avax_usdc.functions.initialize(
            "USDC",
            "USDC",
            "USDC",
            0,
            addresses["avax_usdc_master_minter"],
            self.w3.eth.account.create().address,
            self.w3.eth.account.create().address,
            addresses["avax_usdc_master_minter"]
        ), "avax_usdc_master_minter")
        self.send_transaction(self.avax_usdc.functions.initializeV2("USDC"), "avax_usdc_master_minter")
        self.send_transaction(self.avax_usdc.functions.initializeV2_1(Web3.toChecksumAddress("0xb794f5ea0ba39494ce839613fffba74279579268")), "avax_usdc_master_minter")

        # Deploy and construct required bridge contracts for ETH
        self.eth_message = self.deploy_contract_from_source('src/messages/Message.sol', 'Message')
        self.eth_messageTransmitter = self.deploy_contract_from_source('src/MessageTransmitter.sol', 'MessageTransmitter', 
            libraries={'src/messages/Message.sol:Message': self.eth_message.address}, 
            constructor_args = [eth_domain, addresses["attester"], maxMessageBodySize, version], caller="eth_message_transmitter_deployer")
        self.eth_burnMessage = self.deploy_contract_from_source('src/messages/BurnMessage.sol', 'BurnMessage')
        self.eth_circleBridge = self.deploy_contract_from_source('src/CircleBridge.sol', 'CircleBridge', 
            libraries={'src/messages/Message.sol:Message': self.eth_message.address, 'src/messages/BurnMessage.sol:BurnMessage': self.eth_burnMessage.address}, 
            constructor_args=[self.eth_messageTransmitter.address, message_body_version], caller="eth_circle_bridge_deployer")
        self.eth_circleMinter = self.deploy_contract_from_source('src/CircleMinter.sol', 'CircleMinter', caller="eth_circle_minter_deployer")

        # Deploy and construct required bridge contracts for AVAX
        self.avax_message = self.deploy_contract_from_source('src/messages/Message.sol', 'Message')
        self.avax_messageTransmitter = self.deploy_contract_from_source('src/MessageTransmitter.sol', 'MessageTransmitter', 
            libraries={'src/messages/Message.sol:Message': self.avax_message.address}, 
            constructor_args = [avax_domain, addresses["attester"], maxMessageBodySize, version], caller="avax_message_transmitter_deployer")
        self.avax_burnMessage = self.deploy_contract_from_source('src/messages/BurnMessage.sol', 'BurnMessage')
        self.avax_circleBridge = self.deploy_contract_from_source('src/CircleBridge.sol', 'CircleBridge', 
            libraries={'src/messages/Message.sol:Message': self.avax_message.address, 'src/messages/BurnMessage.sol:BurnMessage': self.avax_burnMessage.address}, 
            constructor_args = [self.avax_messageTransmitter.address, message_body_version], caller="avax_circle_bridge_deployer")
        self.avax_circleMinter = self.deploy_contract_from_source('src/CircleMinter.sol', 'CircleMinter', caller="avax_circle_minter_deployer")

        # configureMinter to add minters
        self.send_transaction(self.eth_usdc.functions.configureMinter(addresses["eth_usdc_master_minter"], minter_allowance), "eth_usdc_master_minter")
        self.send_transaction(self.avax_usdc.functions.configureMinter(addresses["avax_usdc_master_minter"], minter_allowance), "avax_usdc_master_minter")
        self.send_transaction(self.eth_usdc.functions.configureMinter(self.eth_circleMinter.address, minter_allowance), "eth_usdc_master_minter")
        self.send_transaction(self.avax_usdc.functions.configureMinter(self.avax_circleMinter.address, minter_allowance), "avax_usdc_master_minter")

        # addLocalMinter to bridge contracts
        self.send_transaction(self.eth_circleBridge.functions.addLocalMinter(self.eth_circleMinter.address), "eth_circle_bridge_deployer")
        self.send_transaction(self.avax_circleBridge.functions.addLocalMinter(self.avax_circleMinter.address), "avax_circle_bridge_deployer")

        # addLocalCircleBridge to minter contracts
        self.send_transaction(self.eth_circleMinter.functions.addLocalCircleBridge(self.eth_circleBridge.address), "eth_circle_minter_deployer")
        self.send_transaction(self.avax_circleMinter.functions.addLocalCircleBridge(self.avax_circleBridge.address), "avax_circle_minter_deployer")

        # setLocalTokenEnabledStatus on minter contracts
        self.send_transaction(self.eth_circleMinter.functions.setLocalTokenEnabledStatus(self.eth_usdc.address, True), "eth_circle_minter_deployer")
        self.send_transaction(self.avax_circleMinter.functions.setLocalTokenEnabledStatus(self.avax_usdc.address, True), "avax_circle_minter_deployer")

        # linkTokenPair
        self.send_transaction(self.eth_circleMinter.functions.linkTokenPair(self.eth_usdc.address, avax_domain, self.to_32byte_hex(self.avax_usdc.address)), "eth_circle_minter_deployer")
        self.send_transaction(self.avax_circleMinter.functions.linkTokenPair(self.avax_usdc.address, eth_domain, self.to_32byte_hex(self.eth_usdc.address)), "avax_circle_minter_deployer")

        # addRemoteCircleBridge
        self.send_transaction(self.eth_circleBridge.functions.addRemoteCircleBridge(avax_domain, self.to_32byte_hex(self.avax_circleBridge.address)), "eth_circle_bridge_deployer")
        self.send_transaction(self.avax_circleBridge.functions.addRemoteCircleBridge(eth_domain, self.to_32byte_hex(self.eth_circleBridge.address)), "avax_circle_bridge_deployer")

    def test_bridge(self):
        # Allocate 100 USDC each to avax_bridge_user and eth_bridge_user
        self.send_transaction(self.avax_usdc.functions.mint(addresses["avax_bridge_user"], mint_amount), "avax_usdc_master_minter")
        self.send_transaction(self.eth_usdc.functions.mint(addresses["eth_bridge_user"], mint_amount), "eth_usdc_master_minter")
        self.verify_balances(100, 100)

        # Approve USDC transfer from avax_bridge_user to avax_circleBridge
        self.send_transaction(self.avax_usdc.functions.approve(self.avax_circleBridge.address, mint_amount), "avax_bridge_user")

        # depositForBurn from avax_bridge_user to avax_circleBridge
        self.send_transaction(self.avax_circleBridge.functions.depositForBurn(mint_amount, eth_domain, self.to_32byte_hex(addresses["eth_bridge_user"]), self.avax_usdc.address), "avax_bridge_user")
        self.verify_balances(100, 0)

        # parse MessageSent event emitted by avax_messageTransmitter
        avax_message_sent_filter = self.avax_messageTransmitter.events.MessageSent.createFilter(fromBlock="0x0")
        avax_message_bytes = Web3.toHex(avax_message_sent_filter.get_new_entries()[0]['args']['message'])
        avax_signed_message_bytes = hex(0x2e9d278d201a698f5908de5cbc9c1f7ee21b41f9ed5ec6104ce33045846bfe1b6373c1293d71b622ba3939d6a7081d814d5820eaadc04cb5c888f399bd3c60e01c)

        # receiveMessage with eth_messageTransmitter to eth_bridge_user
        self.send_transaction(self.eth_messageTransmitter.functions.receiveMessage(avax_message_bytes, avax_signed_message_bytes), "eth_bridge_user")
        self.verify_balances(200, 0)
    
        # Approve USDC transfer from eth_bridge_user to eth_circleBridge
        self.send_transaction(self.eth_usdc.functions.approve(self.eth_circleBridge.address, mint_amount), "eth_bridge_user")

        # depositForBurn from eth_bridge_user to eth_circleBridge
        self.send_transaction(self.eth_circleBridge.functions.depositForBurn(mint_amount, avax_domain, self.to_32byte_hex(addresses["avax_bridge_user"]), self.eth_usdc.address), "eth_bridge_user")
        self.verify_balances(100, 0)

        # parse MessageSent event emitted by eth_messageTransmitter
        eth_message_sent_filter = self.eth_messageTransmitter.events.MessageSent.createFilter(fromBlock="0x0")
        eth_message_bytes = Web3.toHex(eth_message_sent_filter.get_new_entries()[0]['args']['message'])
        eth_signed_message_bytes = hex(0x6868dd267f550dae138be13553ea41a3ec90b053f210c5c07df7d845069d2b526bbd4464c64adb0474c9ace4c2fd7b81c1fdae24483762a4e90a3538461e25ab1c)

        # receiveMessage with avax_messageTransmitter to avax_bridge_user
        self.send_transaction(self.avax_messageTransmitter.functions.receiveMessage(eth_message_bytes, eth_signed_message_bytes), "avax_bridge_user")
        self.verify_balances(100, 100)

if __name__ == '__main__':
    unittest.main()
